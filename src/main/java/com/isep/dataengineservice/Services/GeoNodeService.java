package com.isep.dataengineservice.Services;

import com.isep.dataengineservice.Models.GeoPosition;
import com.isep.dataengineservice.Models.Place;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import java.util.*;

@Service

public class GeoNodeService {

    @Autowired
    KafkaTemplate<String, GeoPosition> kafkaTemplate;
    private static final int earthRadius = 6371;

    //number of position desired, the larger, the more places we get
    private static final int numberOfDesiredNodes = 5000000;

    // the maximum distance between initial point and the found geoNode. for example, if we want places in 'Paris' we won't exceed 20KM circle, therefore never leaving the city.
    private static final int maxDistance = 200000;
    @Autowired
    KafkaTemplate<String, List<Place>> kafkaPlaceTemplate;
    Map<GeoPosition, String> directionsMap = new HashMap<>();

    public Set<GeoPosition> BfsSearchGeoNodes(GeoPosition geoNode, LinkedHashSet<GeoPosition> allGeoNodes) {
        //starts with geoNode and returns a list of geoPositions in a radius
        Queue<GeoPosition> queue = new LinkedList<>();
        Map<GeoPosition, String> directionsMap = new HashMap<>();
        geoNode.setDistanceFromStart(0);
        queue.add(geoNode);

        while (!queue.isEmpty() && allGeoNodes.size() < numberOfDesiredNodes) {
            GeoPosition currentNode = queue.poll();
            directionsMap.remove(currentNode);
            List<GeoPosition> neighbors = getNeighboringNodesInAllDirections(currentNode);

            for (GeoPosition neighbor : neighbors) {
                    double distanceFromStart = calculateDistanceBetweenGeoNodes(geoNode.getLat(), geoNode.getLon(), neighbor.getLat(), neighbor.getLon());
                    neighbor.setDistanceFromStart(distanceFromStart);

                    if ( distanceFromStart <= maxDistance && !allGeoNodes.contains(neighbor)) {
                        allGeoNodes.add(neighbor);
                        queue.add(neighbor);
                    }
            }
        }
        return allGeoNodes;
    }

    public List<GeoPosition> getNeighboringNodesInAllDirections(GeoPosition currentGeoNode) {
        List<GeoPosition> neighbors = new ArrayList<>();
        GeoPosition east = getNextGeoNode(currentGeoNode.getLat(), currentGeoNode.getLon(), 0);
        GeoPosition north = getNextGeoNode(currentGeoNode.getLat(), currentGeoNode.getLon(), Math.PI / 2);
        GeoPosition west = getNextGeoNode(currentGeoNode.getLat(), currentGeoNode.getLon(), Math.PI);
        GeoPosition south = getNextGeoNode(currentGeoNode.getLat(), currentGeoNode.getLon(), 3 * Math.PI / 2);
        directionsMap.put(east, "east");
        directionsMap.put(north, "north");
        directionsMap.put(west, "west");
        directionsMap.put(south, "south");

        neighbors.add(east);
        neighbors.add(west);
        neighbors.add(north);
        neighbors.add(south);

        return neighbors;
    }


    public static GeoPosition getNextGeoNode(double lat, double lon, double theta) {
        //uses the haversine formula to get geo positions that are geoDistance kilometers away from current geoPosition and that are theta direction away.
        //used to get nodes in North/West/East of the current node
        //the math is generated by ChatGPT, analyzed and cleaned by me.


        /*we calculate the center of the next circle, this affects the result ALOT. generally the lower the better but we
        may get stuck on couple of geoPositions. */
        double geoDistance = 0.7;

        //we convert our lat and lon  to radian
        double startLatitudeRadians = Math.toRadians(lat);
        double startLongitudeRadians = Math.toRadians(lon);

        //use Haversine to calculate new lat & new lon
        double latitude = Math.asin(
                Math.sin(startLatitudeRadians) * Math.cos(geoDistance / earthRadius) +
                        Math.cos(startLatitudeRadians) * Math.sin(geoDistance / earthRadius) * Math.cos(theta)
        );
        double longitude = startLongitudeRadians + Math.atan2(
                Math.sin(theta) * Math.sin(geoDistance / earthRadius) * Math.cos(startLatitudeRadians),
                Math.cos(geoDistance / earthRadius) - Math.sin(startLatitudeRadians) * Math.sin(latitude)
        );
        //convert back to degrees
        double newLat = Math.toDegrees(latitude);
        double newLon = (Math.toDegrees(longitude) + 540) % 360 - 180;

        return GeoPosition.builder().lat(newLat).lon(newLon).build();
    }


    public double calculateDistanceBetweenGeoNodes(double lat1, double lon1, double lat2, double lon2) {
        //the haversine formula to calculate the distance between geoNodes
        //used it to verify that we're not returning nodes that are too far or too close
        //the math is generated by ChatGPT, analyzed and cleaned by me.

        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        lat1 = Math.toRadians(lat1);
        lat2 = Math.toRadians(lat2);
        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        double distance = earthRadius * c * 1000; // convert to meters
        return distance;
    }

    private boolean testRapidApiKey(String key){
        RestTemplate restTemplate = new RestTemplate();
        String uri = "https://opentripmap-places-v1.p.rapidapi.com/en/places/radius?radius=500&lon=0&lat=0";
        HttpHeaders headers = new HttpHeaders();
        headers.add("X-RapidAPI-Key", key);
        headers.add("X-RapidAPI-Host", "opentripmap-places-v1.p.rapidapi.com");
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        ResponseEntity<Place.ApiResponse> response = restTemplate.exchange(uri, HttpMethod.GET, requestEntity, Place.ApiResponse.class);
        return response.getStatusCodeValue() == 200;
    }

    private String getValidApiKey(){
        if(testRapidApiKey("6a4f81847bmsh8785c9220ccebdfp1b97bfjsn74f82815c241")){
            return "6a4f81847bmsh8785c9220ccebdfp1b97bfjsn74f82815c241";
        }
        else if(testRapidApiKey("01f3cd1780mshb2b87fa150c52f3p195ac3jsn0517fb556b09")){
            return "01f3cd1780mshb2b87fa150c52f3p195ac3jsn0517fb556b09";
        }
        else if(testRapidApiKey("951fb39597msh0bafa42f6ead260p1823fcjsnf3f2da6d6ce2")){
            return "951fb39597msh0bafa42f6ead260p1823fcjsnf3f2da6d6ce2";
        }
        else{
            return "c4d4c4a3afmsh8073c2210da8497p1bf278jsne8174b51a3ec";
        }
    }

    public GeoPosition getGeoPosition(String city){
        String rapidApiKey = getValidApiKey();
        RestTemplate restTemplate = new RestTemplate();
        String uri = "https://opentripmap-places-v1.p.rapidapi.com/en/places/geoname?name="+city;
        HttpHeaders headers = new HttpHeaders();
        headers.add("X-RapidAPI-Key", rapidApiKey);
        headers.add("X-RapidAPI-Host", "opentripmap-places-v1.p.rapidapi.com");
        HttpEntity<String> requestEntity = new HttpEntity<>(headers);
        ResponseEntity<GeoPosition> response = restTemplate.exchange(uri, HttpMethod.GET, requestEntity, GeoPosition.class);
        GeoPosition geoPosition = response.getBody();
        return geoPosition;
    }




}
